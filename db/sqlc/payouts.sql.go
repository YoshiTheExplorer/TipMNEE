// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payouts.sql

package db

import (
	"context"
)

const resolvePayoutByChannelID = `-- name: ResolvePayoutByChannelID :one
SELECT p.address
FROM social_links sl
JOIN payouts p ON p.user_id = sl.user_id
WHERE sl.platform = $1
  AND sl.platform_user_id = $2
  AND sl.verified_at IS NOT NULL
  AND p.chain = $3
LIMIT 1
`

type ResolvePayoutByChannelIDParams struct {
	Platform       string `json:"platform"`
	PlatformUserID string `json:"platform_user_id"`
	Chain          string `json:"chain"`
}

func (q *Queries) ResolvePayoutByChannelID(ctx context.Context, arg ResolvePayoutByChannelIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, resolvePayoutByChannelID, arg.Platform, arg.PlatformUserID, arg.Chain)
	var address string
	err := row.Scan(&address)
	return address, err
}

const upsertPayout = `-- name: UpsertPayout :one
INSERT INTO payouts (
  user_id, chain, address, created_at, updated_at
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT (user_id, chain) DO UPDATE
SET address = EXCLUDED.address,
    updated_at = NOW()
RETURNING id, user_id, chain, address, created_at, updated_at
`

type UpsertPayoutParams struct {
	UserID  int64  `json:"user_id"`
	Chain   string `json:"chain"`
	Address string `json:"address"`
}

func (q *Queries) UpsertPayout(ctx context.Context, arg UpsertPayoutParams) (Payout, error) {
	row := q.db.QueryRowContext(ctx, upsertPayout, arg.UserID, arg.Chain, arg.Address)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Chain,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
