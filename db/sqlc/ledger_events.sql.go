// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ledger_events.sql

package db

import (
	"context"
	"database/sql"
)

const backfillLedgerEventsUserIDForChannel = `-- name: BackfillLedgerEventsUserIDForChannel :exec
UPDATE ledger_events
SET user_id = $1,
    updated_at = NOW()
WHERE platform = $2
  AND platform_user_id = $3
  AND user_id IS NULL
`

type BackfillLedgerEventsUserIDForChannelParams struct {
	UserID         sql.NullInt64 `json:"user_id"`
	Platform       string        `json:"platform"`
	PlatformUserID string        `json:"platform_user_id"`
}

func (q *Queries) BackfillLedgerEventsUserIDForChannel(ctx context.Context, arg BackfillLedgerEventsUserIDForChannelParams) error {
	_, err := q.db.ExecContext(ctx, backfillLedgerEventsUserIDForChannel, arg.UserID, arg.Platform, arg.PlatformUserID)
	return err
}

const getEarningsSummaryForUser = `-- name: GetEarningsSummaryForUser :one
SELECT
  COALESCE(SUM(CASE WHEN event_type IN ('TIP_DIRECT','TIP_ESCROW') THEN amount_raw ELSE 0 END), 0)::text AS earned_raw,
  COALESCE(SUM(CASE WHEN event_type = 'WITHDRAW' THEN amount_raw ELSE 0 END), 0)::text AS withdrawn_raw,
  (
    COALESCE(SUM(CASE WHEN event_type IN ('TIP_DIRECT','TIP_ESCROW') THEN amount_raw ELSE 0 END), 0)
    -
    COALESCE(SUM(CASE WHEN event_type = 'WITHDRAW' THEN amount_raw ELSE 0 END), 0)
  )::text AS pending_raw
FROM ledger_events
WHERE user_id = $1::bigint
`

type GetEarningsSummaryForUserRow struct {
	EarnedRaw    string `json:"earned_raw"`
	WithdrawnRaw string `json:"withdrawn_raw"`
	PendingRaw   string `json:"pending_raw"`
}

func (q *Queries) GetEarningsSummaryForUser(ctx context.Context, dollar_1 int64) (GetEarningsSummaryForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getEarningsSummaryForUser, dollar_1)
	var i GetEarningsSummaryForUserRow
	err := row.Scan(&i.EarnedRaw, &i.WithdrawnRaw, &i.PendingRaw)
	return i, err
}

const listTipsForUser = `-- name: ListTipsForUser :many
SELECT
  id, platform, platform_user_id, user_id, event_type, amount_raw, message,
  tx_hash, log_index, block_time, created_at, updated_at
FROM ledger_events
WHERE user_id = $1
  AND event_type IN ('TIP_DIRECT', 'TIP_ESCROW')
ORDER BY block_time DESC
LIMIT $2 OFFSET $3
`

type ListTipsForUserParams struct {
	UserID sql.NullInt64 `json:"user_id"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

func (q *Queries) ListTipsForUser(ctx context.Context, arg ListTipsForUserParams) ([]LedgerEvent, error) {
	rows, err := q.db.QueryContext(ctx, listTipsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LedgerEvent{}
	for rows.Next() {
		var i LedgerEvent
		if err := rows.Scan(
			&i.ID,
			&i.Platform,
			&i.PlatformUserID,
			&i.UserID,
			&i.EventType,
			&i.AmountRaw,
			&i.Message,
			&i.TxHash,
			&i.LogIndex,
			&i.BlockTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
